# -*- coding: utf-8 -*-
"""HeartAttack_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZzcRjkHCVHu-ckYQo5kl8hgwoevHtq4F
"""

#importing necessary libraries
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

#uploading dataset
df = pd.read_csv('/content/drive/MyDrive/heart_attack_prediction_dataset.csv')

#first few rows of dataset
df.head()

#dataset informmation
df.info()

#dataset description
df.describe()

#checking null values
df.isnull().sum()

# checking dataset shape
df.shape

# counting values of both classes
print(df['Heart Attack Risk'].value_counts(normalize=True)*100)

# Selecting only numerical columns
df_numeric = df.select_dtypes(include=np.number)

# Defining the correlation matrix
corr_matrix = df_numeric.corr()

# Generate the heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap of Numerical Features')
plt.show()

# bar hart for heart attack risk column
risk_counts = df['Heart Attack Risk'].value_counts().reset_index()
risk_counts.columns = ['Risk', 'Count']

fig1 = px.bar(risk_counts, x='Risk', y='Count',
              title="Heart Attack Risk Distribution",
              text='Count')
fig1.show()

# Donut chart for heart attack risk distribution
fig = px.pie(df, names='Heart Attack Risk',
             title='Heart Attack Risk Distribution',
             hole=0.4)
fig.show()

# Histogram for Age Distribution by Heart Attack Risk
fig2 = px.histogram(df, x='Age', color='Heart Attack Risk', barmode='overlay',
                    nbins=40, title="Age Distribution by Heart Attack Risk")
fig2.show()

# Bar chart for Gender vs Heart Attack Risk
fig3 = px.histogram(df, x='Sex', color='Heart Attack Risk', barmode='group',
                    title="Gender vs Heart Attack Risk")
fig3.show()

# Creating boxplot for Cholesterol by Risk
fig4 = px.box(df, x='Heart Attack Risk', y='Cholesterol', color='Heart Attack Risk',
              title="Cholesterol Levels by Heart Attack Risk")
fig4.show()

# Splitting Blood Pressure into systolic and diastolic
df[['Systolic_BP', 'Diastolic_BP']] = df['Blood Pressure'].str.split('/', expand=True).astype(float)
df.drop(columns=['Blood Pressure'], inplace=True) #dropping blood pressure column

# Creating histogram for Systolic Blood Pressure by Heart Attack Risk
fig_systolic_hist = px.histogram(df, x='Systolic_BP', color='Heart Attack Risk',
                                 barmode='overlay', nbins=50,
                                 title="Systolic Blood Pressure Distribution by Heart Attack Risk")
fig_systolic_hist.show()

# Creating histogram for Diastolic Blood Pressure by Heart Attack Risk
fig_diastolic_hist = px.histogram(df, x='Diastolic_BP', color='Heart Attack Risk',
                                  barmode='overlay', nbins=50,
                                  title="Diastolic Blood Pressure Distribution by Heart Attack Risk")
fig_diastolic_hist.show()

# Boxplot for BMI by Risk
fig6 = px.box(df, x='Heart Attack Risk', y='BMI', color='Heart Attack Risk',
                  title="BMI Distribution by Heart Attack Risk")
fig6.show()

# Boxplot for Exercise Hours vs Risk
fig7 = px.box(df, x='Heart Attack Risk', y='Exercise Hours Per Week', color='Heart Attack Risk',
              title="Exercise Hours Per Week by Heart Attack Risk")
fig7.show()

# Bar chart for Smoking vs Risk
fig8 = px.histogram(df, x='Smoking', color='Heart Attack Risk', barmode='group',
                    title="Smoking vs Heart Attack Risk")
fig8.show()

# Violin plot for Stress Level vs Risk
fig9 = px.violin(df, x='Heart Attack Risk', y='Stress Level', color='Heart Attack Risk',
                 box=True, points="all", title="Stress Level by Heart Attack Risk")
fig9.show()

#replacing sex values into numeric
df['Sex'] = df['Sex'].replace({'Male': 0, 'Female': 1})

#dropping Patient ID', 'Country', 'Continent', 'Hemisphere' columns from the dataset
df.drop(columns=['Patient ID', 'Country', 'Continent', 'Hemisphere'], inplace=True)

#dataset head
df.head()

# importing algorithms, data splitting and scaling
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC

# Defining features and target
X = df.drop(columns=['Heart Attack Risk'])
y = df['Heart Attack Risk']

# encoding categorical columns
categorical_cols = X.select_dtypes(include=['object']).columns
X = pd.get_dummies(X, columns=categorical_cols, drop_first=True)

#checking columns names
df.columns

#dataset splittinng
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=99, stratify=y
)

# applying standard scaler on numeric columns
numeric_cols = X_train.select_dtypes(include=['float64','int64']).columns

scaler = StandardScaler()
X_train_scaled = X_train.copy()
X_test_scaled = X_test.copy()
X_train_scaled[numeric_cols] = scaler.fit_transform(X_train[numeric_cols])
X_test_scaled[numeric_cols] = scaler.transform(X_test[numeric_cols])

# initializing decision tree
dt = DecisionTreeClassifier(
    random_state=99,
    class_weight='balanced',  # handle imbalance
    max_depth=6,
    min_samples_leaf=20
)
dt.fit(X_train, y_train)  # Decision Tree uses unscaled data
y_pred_dt = dt.predict(X_test)

print(" Decision Tree Result")
print("Accuracy:\n", accuracy_score(y_test, y_pred_dt))
print("Classification Report:\n", classification_report(y_test, y_pred_dt))

# Calculate the confusion matrix for Decision Tree
cm_dt = confusion_matrix(y_test, y_pred_dt)

# Display the confusion matrix using a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(cm_dt, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted No Risk', 'Predicted Risk'],
            yticklabels=['Actual No Risk', 'Actual Risk'])
plt.xlabel('Predicted Label')
plt.ylabel('Actual Label')
plt.title('Confusion Matrix for Decision Tree Model')
plt.show()

# Support Vector Machine
svm = SVC(random_state=42)
svm.fit(X_train_scaled, y_train)  # scaled data
y_pred_svm = svm.predict(X_test_scaled)

print("SVM Result Evaluation")
print("Accuracy:\n", accuracy_score(y_test, y_pred_svm))
print("classification report\n", classification_report(y_test, y_pred_svm))

# Calculate the confusion matrix for SVM
cm_svm = confusion_matrix(y_test, y_pred_svm)

# Display the confusion matrix using a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(cm_svm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted No Risk', 'Predicted Risk'],
            yticklabels=['Actual No Risk', 'Actual Risk'])
plt.xlabel('Predicted Label')
plt.ylabel('Actual Label')
plt.title('Confusion Matrix for SVM Model')
plt.show()

# importing KNN
from sklearn.neighbors import KNeighborsClassifier

# Initialize KNN
knn = KNeighborsClassifier(n_neighbors=10)

# Fit on scaled training data
knn.fit(X_train_scaled, y_train)

# Predict on test data
y_pred_knn = knn.predict(X_test_scaled)

# Evaluate
print(" KNN Result")
print("Accuracy:\n", accuracy_score(y_test, y_pred_knn))
print("Classification report:\n", classification_report(y_test, y_pred_knn))

# Calculate the confusion matrix
cm_knn = confusion_matrix(y_test, y_pred_knn)
# Display the confusion matrix using a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(cm_knn, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted No Risk', 'Predicted Risk'],
            yticklabels=['Actual No Risk', 'Actual Risk'])
plt.xlabel('Predicted Label')
plt.ylabel('Actual Label')
plt.title('Confusion Matrix for KNN Model')
plt.show()